# Typed Stack Protection
## 目次
- 概略
- データ構造
- 前処理
- 検証

### 概略
- Shadow Stack と同様に、ブロック情報(後述)を保存する領域を作る。
- ローカル変数にアクセスするタイミング(spレジスタを用いた間接アドレッシング)で、アクセスが正当かどうか検証する。
- 検証はアクセスするデータのサイズを用いて行われる。

### データ構造
- ブロック情報
    - ブロックとは、各スタックフレームに存在するローカル変数の情報をまとめた物である。
    - ブロックのサイズの先頭に持っておく。
    - データの内容は、以下の２つ要素の集合によって構成される。
        - スタックフレーム内の終了オフセット
            - スタックフレーム上に存在するデータの終端アドレス
        - アクセス可能サイズフラグ
            - アクセスされうるデータサイズは、1,2,4,8 であり、また共用体への対応のため、下位4bitにそれぞれ可能かどうかのフラグを設ける。
            - | * | * | * | * | 8 | 4 | 2 | 1 |
    - アクセス可能サイズフラグは8bitなのに対し、4bit使われないため、オフセット情報の上位にくっつけて、12bitにする手もある。
    - もしくは、上位下位でそれぞれ書き込み読み込みを表しても良さそう。
- ブロックスタック
    - バッファオーバーフローを防止する機構なのに、攻撃によってブロックスタック(以降bsと略す)が書き換わってしまったら意味がないため、特殊な領域に書き込みをする
        - データ構造を工夫すれば Shadow Stack も同時に実装できる
    - bsの先頭アドレスはbsp(Block Stack Pointer)というレジスタに保存する。
    - bsは以下の命令によってのみアクセスできる(通常のスタックと違い、領域のサイズがわかっているため、先頭を退避する必要がない)
        - block.push
            - オペラントに指定されたアドレスの先の埋め込まれたブロックを、bsrの先頭にコピーする。
            - bspにブロックのサイズを足す。
        - block.pop
            - bspからブロックのサイズを引く。
            - 0クリアした方が安全かも？

### 前処理
- コンパイラが各スタックフームを構成する際に、ローカル変数のオフセットとデータのサイズをまとめたブロックを .rodata に保存し、そのアドレスをadrとしたとき、以下のような命令を追加する。
    - プロローグ
        ``` block.push adr```
    - エピローグ
        ``` block.pop ```

### 検証
- ローカル変数へのアクセスが発生したとき、bspが指しているブロック情報の中から、アクセス中のオフセットを超えないような最初のブロックを検索する(ブロックは固定長かつローカル変数の数はそこまで大きくならないはずなので、現実的な時間で終了する)。
- メモリ操作系の命令を実行するとき、許可されているサイズ以外のメモリアクセスがった際に、CPU例外を投げるようにする。


